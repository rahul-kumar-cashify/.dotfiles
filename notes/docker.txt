dockerfile
    runs instruction for docker to package application into a image

BUILDING IMAGE FROM DOCKERFILE
------------------------------
docker build -t <repository-name>:<tag> <dir>
docker build -t hello-docker:v1.1 .


MANIGING DOCKER IMAGE
---------------------
docker  image  ls
docker  image  remove  <repository-name>:<tag>
docker  image  tag     <image_id>               <old-repository-name>:<old-tag>  <repository-name>:<tag>

docker  image  save    -o                       <app-name>.tar
    Save one or more images to a tar archive (streamed to STDOUT by default)

docker  image  load    -i                       <dir>.tar
    Load an image from a tar archive or STDIN

docker  image  prune  <repo-name>
    Remove all dangling images. 
        -a  also  remove  all  images  not  referenced  by  any  container.

docker image rm <imageID>
docker image rm $(docker image ls -q)



*******************************************************************************
docker start -i <image-id/tag>
    start a image from local (does not build a image)

docker  run  <image-name/id>
    run a new container

docker  exec  <image-name/id>
    attach session to running container

docker  start  <image-name/id>
    starts a stopped container (previous run by docker run)

docker  stop  <image-name/id>
    stops a running container
*******************************************************************************




CONTAINER LIFECYCLE COMMANDS
----------------------------

Running a Container
    docker run <image-name/id>
        Run a new container.

        Options:
            -it              Interactive mode.
            --name=<name>    Assign a name to the container.
            -d               Detached mode (runs in the background).
            -p 80:3000       Publish a container's port to the host (map port 3000 in container to port 80 on host).

Listing Containers
    docker ps
        Print running containers.

        Options:
            -a               Show all containers (running and stopped).

## Executing Commands in a Running Container
    docker exec -it <container-name/id> bash
        Interact with an already running container.

        Options:
            -u <user-name>   Execute the command as a specified user.
            <container-PID>  ID or name of the running container.

## Removing Containers

    docker container remove <repo-name>
    docker rm <repo-name>
        Remove a stopped container.

        Options:
            -f               Force the removal of a running container.



ATTACH TO RUNNING CONTAINER 
---------------------------
docker exec -it bash 
docker exec -it -u <user-name> <contianer-PID> bash
docker exec command interacts with an already running container


LOGS
----
    docker logs [OPTIONS] CONTAINER
        -f, --follow         Follow log output
        -n, --tail string    Number of lines to show from the end of the logs (default "all")
        -t, --timestamps     Show timestamps


-------------------------------------------------------------------------------
Dockerfile - instructions for building Docker images
    IMAGE              - A snapshot containing everything needed to run a program.

    CONTAINER          - A runnable instance of an image.

    DOCKER DAEMON      - Background service managing Docker containers and images.

    DOCKER REGISTRY    - Repository for storing Docker images (e.g., Docker Hub).

    BUILD CONTEXT      - Files available to the Docker daemon during image build.

    LAYER              - Each instruction creates a new layer; layers are cached.


DESCRIPTION

    FROM <image>
        Set the base image for the new image.
        eg: 
        FROM ubuntu:20.04

    WORKDIR <path>
        Set the working directory for subsequent instructions.
        eg: 
        WORKDIR /app

    COPY <src> <dest>
        Copy files from host to container.
        eg: 
        COPY  .                      /app
        COPY  src/                   /app/src/
        COPY  file1.txt  file2.txt   /app/
        COPY  ["myfile.txt",         "/app/"]
        COPY  ["src/",               "/app/src/"]


    ADD <src> <dest>
        Copy files and URLs; supports automatic extraction of tar files.
        eg: 
        ADD https://example.com/file.tar.gz /app/
        ADD myarchive.tar.gz /app/

    RUN <command>
        Execute command in a new layer; used for installations.
        eg: 
        RUN apt-get update && apt-get install -y python3
        RUN pip install -r requirements.txt

    ENTRYPOINT <command>
        The ENTRYPOINT specifies a command that will always be executed when the container starts.
        --entrypoint     - can be used to override entrypoint
        eg: 
        ENTRYPOINT ["python3", "app.py"]
        ENTRYPOINT ["/usr/bin/myapp"]

        NOTE:
        ***************************************************************************************************
        Docker generally has a default entrypoint which is /bin/sh -c but does not have a default command.
        When you run docker like this: 
                docker run -i -t ubuntu bash 
        the entrypoint is the default: 
                /bin/sh -c, 
        the image is ubuntu and the command is bash.
        ***************************************************************************************************

    CMD <command>
        The CMD specifies arguments that will be fed to the ENTRYPOINT.
        eg: 
        CMD ["python3", "app.py"]
        CMD ["npm", "start"]

        NOTE:
        ****************************************************************************
        RUN performs the step during the image build,ENTRYPOINT set what is the first command that is run which generally to set the shell:
            /bin/sh 
        CMD specifies arguments that will be fed to the ENTRYPOINT.
        If you define CMD and then start your container with a different command e.g. 
            docker run $my_image /bin/bash
        ****************************************************************************



    ENV <key>=<value>
        Set environment variables in the container.
        eg: 
        ENV APP_ENV=production
        ENV DATABASE_URL="postgres://user:password@db:5432/mydb"

    EXPOSE <port>
        Document the ports the container listens on at runtime.
        eg: 
        EXPOSE 8080
        EXPOSE 80 443

    USER <username|UID>
        Specify the username or UID for the container processes.
        eg: 
        USER appuser
        USER 1001

    VOLUME <path>
        Create a mount point for external volumes.
        eg: 
        VOLUME ["/data"]
        VOLUME /mnt/data

    ARG <name>
        Define build-time variables for the Dockerfile.
        eg: 
        ARG VERSION=1.0
        ARG NODE_VERSION=14

    LABEL <key>=<value>
        Add metadata to the image for organization.
        eg: 
        LABEL maintainer="you@example.com"
        LABEL version="1.0" description="My application"

    SHELL <shell>
        Specify the shell for the RUN command.
        eg: 
        SHELL ["/bin/bash", "-c"]
        SHELL ["/bin/sh", "-c"]
-------------------------------------------------------------------------------

VOLUMES
-------

docker volume create <vol-name>
docker volume inspect <vol-name>

    eg:
    ----------------------------------------------------------------
    docker volume create app-data
    docker volume inspect app-data
    [
        {
            "CreatedAt": "2024-09-19T17:42:22Z",
            "Driver": "local",
            "Labels": null,
            "Mountpoint": "/var/lib/docker/volumes/app-data/_data",
            "Name": "app-data",
            "Options": null,
            "Scope": "local"
        }
    ]
    ----------------------------------------------------------------


docker run -it -v <vol|host-filesystem>:<contianer-path> ubuntu
docker run -it -v app-data:/home/app <image>

SHARING SOURCE CODE WITH CONTAINER (DEVELOPMENT)
------------------------------------------------
docker run -it -v $(pwd):<contianer-path> ubuntu



-------------------------------------------------------------------------------
DOCKER COPY
-----------
docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-
docker cp [OPTIONS] SRC_PATH | - CONTAINER:DEST_PATH
    Copy files/folders between a container and the local filesystem

docker cp path/to/file_or_directory_on_host container_name:path/to/file_or_directory_in_container
    Copy a file or directory from the host to a container:

docker cp container_name:path/to/file_or_directory_in_container path/to/file_or_directory_on_host
    Copy a file or directory from a container to the host:

docker cp --follow-link path/to/symlink_on_host container_name:path/to/file_or_directory_in_container
    Copy a file or directory from the host to a container, following symlinks (copies the symlinked files directly, not the symlinks themselves):

cat archive.tar | docker cp - my_container:/path/in/container/
    '-' can also used to work with tar archives. For example, to extract a tar archive from stdin into a container:

docker cp my_container:/path/in/container/ - | tar -xvf -
    To create a tar archive from a container and stream it to stdout:

-------------------------------------------------------------------------------
SHELL FORM
    COPY <source> <destination>
    - Uses the shell to execute the command.
    - Supports shell features such as wildcard expansion and environment variable substitution.
    - Example:
        COPY myfile.txt /app/

EXEC FORM
    COPY ["<source>", "<destination>"]
    - Directly executes the command as an array of arguments, without invoking a shell.
    - Does not support shell features.
    - Preferred for clarity and to avoid shell interpretation issues.
    - Example:
        COPY ["myfile.txt", "/app/"]


DOCKER COMPOSE
--------------

docker-compose build
docker-compose up
        -d detach
        --no-cache                  do not use cache

docker-compose ps 

docker-compose down
docker-compose down --rmi all
    docker-compose down --rmi local can safely remove each 'image' in turn: the
    first time it actually just untags it, ditto the second time, and then the
    third time will remove the image for real.



DOCKER NETWORK
--------------
https://docs.docker.com/engine/network/drivers/

docker run -it --network mynetwork ubuntu                # (by default bridge)
docker run -it --network host ubuntu                     # connect directly to host network 
docker run -it --network none ubuntu                     # isolation

NOTE: 
    container on same network can communicate to each other but will not connect to host so use 
        docker run -it -p <host-port>:<docker-bridge-port> <image>

docker network ls                                          # List existing networks 
docker network create netName                              # Create a network 
docker network rm netName                                  # Remove network 
docker network inspect                                     # Show network details 
docker network connect networkName containerName           # Connect container to a network 
docker network disconnect networkName containerName        # Disconnect network from container


note: there are other more advance network to learn

-------------------------------------------------------------------------------

apt install <package>
apt list
adduser
apt update


commit docker container
